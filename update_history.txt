1. add testing codes in ./unit_test.
use package pytest 6.1.1, docs: https://docs.pytest.org/en/latest/contents.html
run the following cmd when you are in root directory:
pytest

2. put testing codes in several dirs to avoid repeated testing.

3. if testing codes use argparse, then it raises error when running "pytest file_path".
   since argparse will recognize file_path as its args.

4. in ./model/point_process.py line 66:
    mask = ...(transition_time < t)...
    maybe we can change to  
    mask = ...(transition_time <= t)...
    The boundary condition is meanless, and it may cause bugs.

5. notice that self-correcting logic is "A -> Not B", instead of "Not A -> B"

6. In synthetic.py we can divide preds into 3 types:
   1)target pred  2) mapped pred  3)independent pred
   type 2) is copied from 1), and type 3) is random, 
   therefore we only need to synthetic (using thining) 1) type.

   Notice that the generation order is  3) --> 1) --> 2). 
   At time t, we first randomly generate an event t_3 of 3),
   then, synthetic events of 1) in interval [t, t_3].

   Also, 1) can be further divided into 1.1)instant and 1.2)continuous. 

7. how to decide the max intensity point in a short interval? only need to calculate sign of f*w.

8. using seed, we can test correctness of synthetic data.

9.  in./model/point_process.py, intensity_log_sum() function: 
   if (not is_duration_pred) and dataset[sample_ID][target_predicate]['state'][idx]==0:
   missing "not" in first condition, missing "[idx]" in second condition.

10. In closed form integral, the most dfficult part is how to get latest pred.
    Thus currently we only implement for rule body length=1,2, but not for longer rules.

11. Integration can also use cache.

12. experiments arguments:
      hawkes: w=0.1, b=0.2;  Result: w=0.1058, b=0.1926
      sc: w=0.1, b=0.2; Result: w=0.0994, b=0.2009
      a_then_b indep instant pred: w=0.2, b=0.4, indep_intensity= 0.5. Result: w=0.1892, b=0.3749
      (modify is_duration_pred to [0,1])
      (Under current formulation, we can only set target pred to duration, but not other preds.)
      a_then_b indep duration pred: w=0.2, b=0.4, indep_intensity= 0.5.  Result: w=0.1314, b=0.3399

      a_then_c_or_b_then_c, instant pred, target_pred=2, w=[0.1,0.1], b=0.2;  Result: w=[0.0983, 0.1091], b=0.2264
      a_and_b_then_c, instant pred, target_pred =2, w=[0.1], b=0.2; Result: w[1.2760], b=[0.0088]

      the bug "time_tolerence must be 1e-6" disappears, maybe because here we use time_tolerence * 1.1, instead of time_tolerence * 1.001.(floating point presicion problem)

      Maybe, closed Integration on "length-2 rules" and "duration pred" are problematic.

      fix bug on length2-rule-integral,
      [Fixed]a_and_b_then_c w=[0.1], b=0.2, result: w=[0.0938], b=[0.2102]
      fix bug on Equal: in synthetic Equal, new events should not add time_tolerence * 1.1, since that prevent model from capturing this event.
      a_then_b_equal, w=[0.1], b=0.2, time_tolerence=5, result: w=[0.0350], b=[0.0771]
      [Fixed]a_then_b_equal, w=[0.1], b=0.2, time_tolerence=5, result: w=[0.0824], b=[0.2193]

      [Fixed]a_then_c duration pred, w=[0.1], b=[0.4], Result: w=[0.0800], b=[0.3573]
      Notice that in duration case, fe can be negative, so w should be much smaller than b. 
      Otherwise lambda can be negative, leads to wrong closed integral.